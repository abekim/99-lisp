#lang racket

;double...hmm i'm confused but have a hang of things atm

(define (double x)
  (+ x x))

;wutwutwut - factorial now

(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

;apparently a different way of doing things

(define (fact-iter n ans)
  (if (= n 1)
      ans
      (fact-iter (- n 1) (* ans n))))

(define (factorial-new n)
  (fact-iter n 1))

;what does (lambda (f) (f 5)) do?

;((lambda (f) (f 5)) (lambda (f) (* f 2)))

;it takes in an operation with one parameter as an argument and runs it
;Add the #s in a list

(define (sum lst)
  (if (empty? lst)
      0
      (+ (car lst) (sum (cdr lst)))))

(sum '(1 2 3 4 5))

;double all elements in a list
; I CAN'T FIGURE IT OUT :(

;(define (double_dumb lst new)
;  (if (empty? lst)
;    '()
;    (begin (append new (*(car lst) 2))
;           (double_dumb (cdr lst) new))))

;(double_dumb '(1 2 3 4 5) '())

;another way of doing things..

(define (duble lst)
  (map(lambda (x) (* x 2)) lst))

(duble '(1 2 3 4 5))

;square all elements in a list

(define (square lst)
  (map (lambda (x) (* x x)) lst))

(square '(1 2 3 4 5))

;return everything but the last elemnet in the list

(define (butlast lst)
  (reverse (cdr (reverse lst))))

(butlast '(1 2 3 4 5))

;nth n list

(define (nth n x lst)
  (if (= x n)
      (car lst)
      (nth n (+ x 1) (cdr lst))))

(nth 1 0 '(1 2 3 4 5))

;(member? elt lst)

(define (member? elt lst)
  (if (empty? lst)
      0
      (if (eq? elt (car lst))
          1
          (member? elt (cdr lst)))))

(member? 0 '(1 2 3 4 5))

;(index-of elt lst)

(define (index-of elt lst)
  (if (empty? lst)
      -1
      (if (eq? elt (car lst))
          0
          (+ 1 index-of elt (cdr lst)))))

(index-of 4 '(1 2 3 4 5))